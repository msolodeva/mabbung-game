<!DOCTYPE html>
<html lang="ko">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>5ë ˆì¸ íƒ‘ë‹¤ìš´ ìë™ì°¨ íšŒí”¼ ê²Œì„</title>
    <style>
      :root {
        --bg: #0b0f16;
        --panel: #0f1724;
        --road: #1e2636;
        --lane: #e9edf5;
        --player: #35d07f;
        --obstacle: #ff5a52;
        --hud: #e9edf5;
        --accent: #7aa2ff;
        --debug: #ffd166;
        --overlay: rgba(0, 0, 0, 0.5);
        --btn-bg: #1f2a44;
        --btn-bg-hover: #2b3b62;
        --btn-text: #ffffff;
      }
      * { box-sizing: border-box; }
      html, body {
        margin: 0; padding: 0; height: 100%; background: var(--bg); color: var(--hud);
        font-family: system-ui, -apple-system, Segoe UI, Roboto, Noto Sans, sans-serif;
        -webkit-font-smoothing: antialiased; -moz-osx-font-smoothing: grayscale;
      }
      #root {
        position: relative; width: 100vw; height: 100vh; display: grid; place-items: center;
        overflow: hidden; background: radial-gradient(1200px 800px at 50% 20%, #0e1524, #0b0f16 70%);
      }
      /* Letterboxed canvas area computed from JS for best control */
      .stage-wrap { position: relative; }
      canvas { display: block; background: var(--panel); border-radius: 12px; box-shadow: 0 10px 30px rgba(0,0,0,0.35); }

      .hud {
        position: absolute; top: 12px; left: 16px; display: flex; flex-direction: column; gap: 4px; pointer-events: none;
        text-shadow: 0 2px 6px rgba(0,0,0,0.6);
      }
      .hud .line { font-weight: 700; letter-spacing: 0.3px; }
      .hud .hearts { color: #ff5a52; font-size: 18px; letter-spacing: 2px; }
      .icons { position: absolute; top: 12px; right: 16px; display: flex; gap: 10px; }
      .icon { background: rgba(0,0,0,0.35); padding: 6px 10px; border-radius: 999px; font-size: 14px; }

      .overlay { position: absolute; inset: 0; display: none; align-items: center; justify-content: center; background: var(--overlay); }
      .overlay.show { display: flex; }
      .card { background: var(--panel); border: 1px solid #27314a; padding: 20px; border-radius: 12px; width: min(92vw, 440px); box-shadow: 0 6px 20px rgba(0,0,0,0.35); }
      .card h1, .card h2 { margin: 0 0 10px; }
      .card p  { margin: 4px 0; line-height: 1.5; color: #c8d2e6; }
      .row { display: flex; gap: 8px; margin-top: 12px; }
      button { appearance: none; border: 0; border-radius: 8px; padding: 10px 14px; background: var(--btn-bg); color: var(--btn-text); font-weight: 700; cursor: pointer; }
      button:focus-visible { outline: 2px solid var(--accent); outline-offset: 2px; }
      button:hover { background: var(--btn-bg-hover); }

      .sr-only { position: absolute; width: 1px; height: 1px; margin: -1px; padding: 0; border: 0; clip: rect(0 0 0 0); overflow: hidden; }
    </style>
  </head>
  <body>
    <div id="root">
      <div class="stage-wrap">
        <canvas id="game" aria-label="ìë™ì°¨ íšŒí”¼ ê²Œì„ ìº”ë²„ìŠ¤" aria-describedby="controls-desc"></canvas>

        <div class="hud" aria-live="polite">
          <div class="line hearts" id="livesLine" aria-label="ëª©ìˆ¨">â¤ï¸â¤ï¸â¤ï¸</div>
          <div class="line" id="scoreLine">ì ìˆ˜: 0</div>
          <div class="line" id="bestLine">ìµœê³ ì ìˆ˜: 0</div>
        </div>
        <div class="icons">
          <div class="icon" id="pauseIcon" title="ì¼ì‹œì •ì§€ ìƒíƒœ">â¸</div>
          <div class="icon" id="muteIcon" title="ìŒì†Œê±° ìƒíƒœ">ğŸ”Š</div>
        </div>

        <div class="overlay" id="startOverlay">
          <div class="card">
            <h1>5ë ˆì¸ ìë™ì°¨ íšŒí”¼</h1>
            <p>ì¢Œìš°ë¡œ ì¡°í–¥í•˜ë©° ì¥ì• ë¬¼ì„ í”¼í•˜ì„¸ìš”!</p>
            <p><strong>ì¡°ì‘</strong> â€” â†/â†’ ë˜ëŠ” A/D, â†‘/â†“ ë˜ëŠ” W/S(ì•/ë’¤), Space=ì¼ì‹œì •ì§€, R=ì¬ì‹œì‘, H=íˆíŠ¸ë°•ìŠ¤, M=ìŒì†Œê±°</p>
            <div class="row">
              <button id="startBtn" autofocus>ê²Œì„ ì‹œì‘</button>
              <button id="muteBtn">ìŒì†Œê±° ì „í™˜(M)</button>
            </div>
          </div>
        </div>

        <div class="overlay" id="pauseOverlay">
          <div class="card">
            <h2>ì¼ì‹œì •ì§€</h2>
            <p>Spaceë¡œ ì¬ê°œí•˜ê±°ë‚˜, Rë¡œ ì¬ì‹œì‘í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.</p>
            <div class="row">
              <button id="resumeBtn">ì¬ê°œ(Space)</button>
              <button id="restartBtn1">ì¬ì‹œì‘(R)</button>
            </div>
          </div>
        </div>

        <div class="overlay" id="gameOverOverlay">
          <div class="card">
            <h2>ê²Œì„ ì˜¤ë²„</h2>
            <p id="finalScore">ì ìˆ˜: 0</p>
            <p id="bestScore">ìµœê³ ì ìˆ˜: 0</p>
            <div class="row">
              <button id="restartBtn2">ë‹¤ì‹œ ì‹œì‘(R)</button>
              <button id="goStartBtn">ì²˜ìŒ í™”ë©´</button>
            </div>
          </div>
        </div>

        <p id="controls-desc" class="sr-only">
          í‚¤ë³´ë“œ: ì™¼ìª½/ì˜¤ë¥¸ìª½(ë˜ëŠ” A/D) ì¡°í–¥(ë¶€ë“œëŸ¬ìš´ ì¢Œìš° ì´ë™), ìœ„/ì•„ë˜(ë˜ëŠ” W/S) ì•/ë’¤ ì´ë™. ìŠ¤í˜ì´ìŠ¤=ì¼ì‹œì •ì§€/ì¬ê°œ, R=ì¬ì‹œì‘, H=íˆíŠ¸ë°•ìŠ¤, M=ìŒì†Œê±°.
          í„°ì¹˜/ëª¨ë°”ì¼: ì¢Œ/ìš° íƒ­ìœ¼ë¡œ ë ˆì¸ ì´ë™, ìƒ/í•˜ ìŠ¤ì™€ì´í”„ë¡œ ì•/ë’¤ ì´ë™.
        </p>
      </div>
    </div>

    <script>
      // ===== ìƒìˆ˜/ì„¤ì • (car namespace) =====
      const CFG = {
        DESIGN_W: 960,
        DESIGN_H: 540,
        LANE_COUNT: 5,
        ROAD_PADDING_X: 0.18,   // ì¢Œìš° ì—¬ë°± (ë¹„ìœ¨)
        PLAYER_W_RATE: 0.5,     // ì°¨ ë„ˆë¹„ = ë ˆì¸í­ * rate (ë ˆì¸ì˜ ì ˆë°˜ í¬ê¸°)
        PLAYER_H_RATE: 1.6,     // ì°¨ ë†’ì´ = ë„ˆë¹„ * rate
        HORIZ_SPEED: 900,       // ì¢Œìš° ì´ë™ ì†ë„(px/s) - í‚¤ ëˆ„ë¦„ ë™ì•ˆ ë¶€ë“œëŸ½ê²Œ ì´ë™
        VERT_SPEED: 600,        // ìƒí•˜ ì´ë™ ì†ë„(px/s) - íƒ€ê²Ÿ Yë¡œ ë¶€ë“œëŸ½ê²Œ
        LANE_SNAP_EPS: 1.5,     // ë ˆì¸ ì„¼í„° ìŠ¤ëƒ… í—ˆìš© ì˜¤ì°¨(px)
        BASE_SPEED: 260,        // ì‹œì‘ ì†ë„(px/s)
        MAX_SPEED: 680,         // ìµœëŒ€ ì†ë„(px/s)
        RAMP_TIME: 80,          // ìµœëŒ€ ì†ë„ê¹Œì§€ ë„ë‹¬í•˜ëŠ” ì‹œê°„(ì´ˆ) â€” ê°€ì†ë„ ì™„í™”
        BASE_SPAWN: 0.95,       // ì‹œì‘ ìŠ¤í° ê°„ê²©(s)
        MIN_SPAWN: 0.35,        // ìµœì†Œ ìŠ¤í° ê°„ê²©(s)
        SCORE_PER_SEC: 10,
        NEAR_MISS_BONUS: 25,
        NEAR_MISS_THRESHOLD: 26,// í”Œë ˆì´ì–´ ìƒë‹¨ì—ì„œ ì´ ê±°ë¦¬ ë‚´ ìŠ¤ì¹˜ë©´ ë³´ë„ˆìŠ¤
        POOL_SIZE: 36,
        STORAGE_KEY: 'car3lane_highscore_v1',
        HIT_INVULN: 1.0,       // í”¼ê²© í›„ ë¬´ì  ì‹œê°„(s)
        OBST_STEER_MAX: 180,    // ì¥ì• ë¬¼ ì¢Œìš° ìµœëŒ€ ì¡°í–¥ ì†ë„(px/s)
        OBST_WANDER_MIN: 0.5,   // ë°©í–¥ ì¬ê²°ì • ìµœì†Œ ê°„ê²©(s)
        OBST_WANDER_MAX: 1.2    // ë°©í–¥ ì¬ê²°ì • ìµœëŒ€ ê°„ê²©(s)
      };

      // ===== ìœ í‹¸: RNG (ì‹œë“œ ê³ ì •) =====
      function mulberry32(seed) { // ê°„ë‹¨í•˜ê³  ë¹ ë¥¸ RNG
        let t = seed >>> 0;
        return function() {
          t += 0x6D2B79F5;
          let r = Math.imul(t ^ (t >>> 15), 1 | t);
          r ^= r + Math.imul(r ^ (r >>> 7), 61 | r);
          return ((r ^ (r >>> 14)) >>> 0) / 4294967296;
        };
      }
      function seededFromQuery(defaultSeed = Date.now() & 0xffffffff) {
        const url = new URL(window.location.href);
        const s = url.searchParams.get('seed');
        const n = s != null ? (parseInt(s, 10) || 0) : defaultSeed;
        return mulberry32(n);
      }

      // ===== ìœ í‹¸: ìˆ˜í•™/ì¶©ëŒ =====
      const clamp = (v, lo, hi) => Math.min(hi, Math.max(lo, v));
      function aabb(ax, ay, aw, ah, bx, by, bw, bh) {
        return ax < bx + bw && ax + aw > bx && ay < by + bh && ay + ah > by;
      }

      // ===== ì˜¤ë””ì˜¤ ìœ í‹¸ (WebAudio) =====
      class AudioMgr {
        constructor() { this.ctx = null; this.muted = false; }
        ensureCtx() {
          if (!this.ctx) this.ctx = new (window.AudioContext || window.webkitAudioContext)();
          if (this.ctx.state === 'suspended') this.ctx.resume();
        }
        setMuted(v) { this.muted = !!v; }
        playNear() {
          if (this.muted) return; this.ensureCtx();
          const t = this.ctx.currentTime;
          const o = this.ctx.createOscillator();
          const g = this.ctx.createGain();
          o.type = 'sine'; o.frequency.setValueAtTime(880, t);
          o.frequency.exponentialRampToValueAtTime(1320, t + 0.08);
          g.gain.setValueAtTime(0.001, t);
          g.gain.exponentialRampToValueAtTime(0.08, t + 0.02);
          g.gain.exponentialRampToValueAtTime(0.0001, t + 0.16);
          o.connect(g).connect(this.ctx.destination); o.start(t); o.stop(t + 0.18);
        }
        playCrash() {
          if (this.muted) return; this.ensureCtx();
          const t = this.ctx.currentTime;
          const o = this.ctx.createOscillator();
          const g = this.ctx.createGain();
          o.type = 'sawtooth';
          o.frequency.setValueAtTime(180, t);
          o.frequency.exponentialRampToValueAtTime(80, t + 0.22);
          g.gain.setValueAtTime(0.001, t);
          g.gain.exponentialRampToValueAtTime(0.18, t + 0.02);
          g.gain.exponentialRampToValueAtTime(0.0001, t + 0.28);
          o.connect(g).connect(this.ctx.destination); o.start(t); o.stop(t + 0.3);
        }
      }

      // ===== ì…ë ¥ =====
      class Input {
        constructor(targetEl) {
          this.left = false; this.right = false; this.up = false; this.down = false;
          this.onAction = null; // x: -1/1
          this.onActionY = null; // y: -1/1
          this.onPause = null; this.onRestart = null; this.onToggleDebug = null; this.onToggleMute = null;
          this._bindKeyboard(); this._bindTouch(targetEl);
        }
        _bindKeyboard() {
          window.addEventListener('keydown', (e) => {
            if (e.repeat) return;
            const k = e.key.toLowerCase();
            // í‚¤ë³´ë“œ: ì¢Œìš°ëŠ” ë ˆì¸ ë³€ê²½ ëŒ€ì‹  "ëˆ„ë¥´ê³  ìˆëŠ” ë™ì•ˆ" ë¶€ë“œëŸ¬ìš´ ì´ë™ì— ì‚¬ìš©
            if (k === 'arrowleft' || k === 'a') { this.left = true; e.preventDefault(); }
            else if (k === 'arrowright' || k === 'd') { this.right = true; e.preventDefault(); }
            else if (k === 'arrowup' || k === 'w') { this.up = true; this.onActionY && this.onActionY(-1); e.preventDefault(); }
            else if (k === 'arrowdown' || k === 's') { this.down = true; this.onActionY && this.onActionY(1); e.preventDefault(); }
            else if (k === ' ' ) { this.onPause && this.onPause(); e.preventDefault(); }
            else if (k === 'r') { this.onRestart && this.onRestart(); e.preventDefault(); }
            else if (k === 'h') { this.onToggleDebug && this.onToggleDebug(); e.preventDefault(); }
            else if (k === 'm') { this.onToggleMute && this.onToggleMute(); e.preventDefault(); }
          }, { passive: false });
          window.addEventListener('keyup', (e) => {
            const k = e.key.toLowerCase();
            if (k === 'arrowleft' || k === 'a') this.left = false;
            else if (k === 'arrowright' || k === 'd') this.right = false;
            else if (k === 'arrowup' || k === 'w') this.up = false;
            else if (k === 'arrowdown' || k === 's') this.down = false;
          });
        }
        _bindTouch(el) {
          let startX = 0, startY = 0, activeId = null;
          const threshold = 24;
          el.addEventListener('pointerdown', (e) => {
            if (e.pointerType === 'mouse') return; activeId = e.pointerId; startX = e.clientX; startY = e.clientY;
          });
          el.addEventListener('pointerup', (e) => {
            if (e.pointerType === 'mouse') return; if (e.pointerId !== activeId) return; const dx = e.clientX - startX; const dy = e.clientY - startY; activeId = null;
            if (Math.abs(dx) < threshold && Math.abs(dy) < threshold) {
              const rect = el.getBoundingClientRect(); const mid = rect.left + rect.width/2;
              if (e.clientX < mid) this.onAction && this.onAction(-1); else this.onAction && this.onAction(1);
              return;
            }
            if (Math.abs(dy) > Math.abs(dx)) { this.onActionY && this.onActionY(dy < 0 ? -1 : 1); }
            else { this.onAction && this.onAction(dx < 0 ? -1 : 1); }
          });
          // Prevent double-tap zoom on iOS
          let lastTouch = 0;
          el.addEventListener('touchend', (e) => {
            const now = Date.now(); if (now - lastTouch < 300) e.preventDefault(); lastTouch = now;
          }, { passive: false });
        }
      }

      // ===== í”Œë ˆì´ì–´ / ì¥ì• ë¬¼ =====
      class Player {
        constructor() { this.lane = 2; this.laneTarget = 2; this.x = 0; this.y = 0; this.yTarget = 0; this.w = 0; this.h = 0; }
        setSize(w, h) { this.w = w; this.h = h; }
        setLane(laneIndex, laneCenters) {
          this.lane = clamp(laneIndex, 0, laneCenters.length - 1);
          this.laneTarget = this.lane;
          this.x = laneCenters[this.lane] - this.w/2; // ì¦‰ì‹œ ë°°ì¹˜(ë¦¬ì‚¬ì´ì¦ˆ/ì‹œì‘ìš©)
        }
        move(dx, laneCenters) { // (í„°ì¹˜ ì „ìš©) ë ˆì¸ ë³€ê²½
          this.laneTarget = clamp(this.laneTarget + dx, 0, laneCenters.length - 1);
        }
        addX(dx, roadX, roadW) { // ì¢Œìš° ì—°ì† ì´ë™(í‚¤ë³´ë“œ)
          const minX = roadX;
          const maxX = roadX + roadW - this.w;
          this.x = clamp(this.x + dx, minX, maxX);
        }
        setBottomY(designH, margin=16) { this.y = designH - this.h - margin; this.yTarget = this.y; }
        setTargetY(y, designH, margin=16) { const minY = margin; const maxY = designH - this.h - margin; this.yTarget = clamp(y, minY, maxY); }
        addTargetY(dy, designH, margin=16) { this.setTargetY(this.yTarget + dy, designH, margin); }
        moveY(dir, designH, margin=16) { const step = this.h * 0.9; this.addTargetY(dir * step, designH, margin); }
        update(dt, laneCenters, designH) {
          // X: ì—°ì† ì´ë™ì€ step()ì—ì„œ ì²˜ë¦¬ (ì—¬ê¸°ì„œëŠ” ë ˆì¸ ìŠ¤ëƒ… ì—†ìŒ)
          if (this.lane !== this.laneTarget) {
            // í„°ì¹˜ë¡œ ë ˆì¸ ë³€ê²½ëœ ê²½ìš°ì—ë§Œ ë¶€ë“œëŸ½ê²Œ ì„¼í„°ë¡œ ì´ë™
            const targetX = laneCenters[this.laneTarget] - this.w/2;
            const dx = targetX - this.x;
            const maxStepX = CFG.HORIZ_SPEED * dt;
            if (Math.abs(dx) <= maxStepX) { this.x = targetX; this.lane = this.laneTarget; }
            else { this.x += Math.sign(dx) * maxStepX; }
          }

          // Y: íƒ€ê²Ÿ Yë¡œ ì´ë™
          const dy = this.yTarget - this.y;
          const maxStepY = CFG.VERT_SPEED * dt;
          if (Math.abs(dy) <= maxStepY) this.y = this.yTarget; else this.y += Math.sign(dy) * maxStepY;
        }
        rect() { return { x: this.x, y: this.y, w: this.w, h: this.h }; }
        draw(ctx) {
          ctx.fillStyle = getComputedStyle(document.documentElement).getPropertyValue('--player');
          ctx.fillRect(this.x, this.y, this.w, this.h);
          // ê°„ë‹¨í•œ ì°½/ë””í…Œì¼
          ctx.fillStyle = 'rgba(0,0,0,0.3)';
          ctx.fillRect(this.x + this.w*0.2, this.y + this.h*0.15, this.w*0.6, this.h*0.2);
          ctx.fillRect(this.x + this.w*0.25, this.y + this.h*0.65, this.w*0.5, this.h*0.2);
        }
      }

      class Obstacle { // í’€ë§ ê°ì²´
        constructor() {
          this.active = false; this.lane = 0; this.x = 0; this.y = -100; this.w = 0; this.h = 0; this.speed = 0; this.nearGiven = false;
          this.vx = 0; this.minX = 0; this.maxX = 0; this._wander = 0; this._rng = null;
        }
        spawn(lane, x, y, w, h, speed, minX, maxX, rng) {
          this.active = true; this.lane = lane; this.x = x; this.y = y; this.w = w; this.h = h; this.speed = speed; this.nearGiven = false;
          this.minX = minX; this.maxX = Math.max(minX, maxX); this._rng = rng;
          // ì´ˆê¸° ì¢Œìš° ì†ë„ ëœë¤ ì„¤ì •
          const s = CFG.OBST_STEER_MAX * (0.4 + this._rng() * 0.6);
          this.vx = (this._rng() < 0.5 ? -1 : 1) * s;
          this._wander = CFG.OBST_WANDER_MIN + this._rng() * (CFG.OBST_WANDER_MAX - CFG.OBST_WANDER_MIN);
        }
        update(dt) {
          if (!this.active) return;
          // ìˆ˜ì§ ì´ë™
          this.y += this.speed * dt;
          // ì¢Œìš° ë°©í™©(ì°¨ì„  ë‚´ë¶€ì—ì„œ ë§¤ë„ëŸ½ê²Œ)
          this._wander -= dt;
          if (this._wander <= 0 && this._rng) {
            const s = CFG.OBST_STEER_MAX * (0.4 + this._rng() * 0.6);
            this.vx = (this._rng() * 2 - 1) * s; // -s..+s
            this._wander = CFG.OBST_WANDER_MIN + this._rng() * (CFG.OBST_WANDER_MAX - CFG.OBST_WANDER_MIN);
          }
          // ì´ë™ ë° ê²½ê³„ ì²˜ë¦¬(ë°˜ì‚¬)
          this.x += this.vx * dt;
          if (this.x < this.minX) { this.x = this.minX; this.vx = Math.abs(this.vx); }
          else if (this.x > this.maxX) { this.x = this.maxX; this.vx = -Math.abs(this.vx); }
        }
        offscreen(H) { return this.y > H + 10; }
        kill() { this.active = false; }
        rect() { return { x: this.x, y: this.y, w: this.w, h: this.h }; }
        draw(ctx) {
          ctx.fillStyle = getComputedStyle(document.documentElement).getPropertyValue('--obstacle');
          ctx.fillRect(this.x, this.y, this.w, this.h);
        }
      }

      class Spawner {
        constructor(rng) { this.rng = rng; this.cool = 0; this.elapsed = 0; }
        update(dt, elapsedTotal) {
          this.elapsed = elapsedTotal; this.cool -= dt; if (this.cool < 0) this.cool = 0;
        }
        nextInterval() { // ì‹œê°„ ê²½ê³¼ì— ë”°ë¼ ìŠ¤í° ë¹¨ë¼ì§
          const t = Math.min(1, this.elapsed / CFG.RAMP_TIME); // ë” ì²œì²œíˆ ë¹¨ë¼ì§
          const rate = CFG.BASE_SPAWN + (CFG.MIN_SPAWN - CFG.BASE_SPAWN) * t; // lerp
          return clamp(rate, CFG.MIN_SPAWN, CFG.BASE_SPAWN);
        }
        shouldSpawn() { return this.cool === 0; }
        // í˜„ì¬ ì¥ì• ë¬¼ë“¤ì´ í”Œë ˆì´ì–´ yì—ì„œ ë®ëŠ” ì‹œê°„ êµ¬ê°„(ë¯¸ë˜ ê¸°ì¤€)ì„ ë ˆì¸ë³„ë¡œ ê³„ì‚°
        _laneCoverageIntervals(obstacles, pr) {
          const lanes = Array(CFG.LANE_COUNT).fill(null);
          for (let i = 0; i < obstacles.length; i++) {
            const o = obstacles[i]; if (!o.active) continue; const v = o.speed; if (v <= 0.001) continue;
            const tEnter = (pr.y - (o.y + o.h)) / v; // bottom -> player top
            const tExit  = (pr.y + pr.h - o.y) / v;   // top -> player bottom
            if (tExit <= 0) continue; // ì´ë¯¸ ì§€ë‚˜ê°
            const itv = { s: Math.max(0, tEnter), e: tExit };
            // ê°€ì¥ ì´ë¥¸ ì‹œì‘ì„ ìœ ì§€
            const cur = lanes[o.lane];
            if (!cur || itv.s < cur.s) lanes[o.lane] = itv;
          }
          return lanes;
        }
        spawn(obstacles, laneCenters, size, speed, pr) {
          // ì•ˆì „ì„± ë³´ì¥: ê°™ì€ ì‹œê°„ëŒ€ì— ëª¨ë“  ë ˆì¸ì´ ë™ì‹œì— ë§‰íˆëŠ” ìƒí™© ê¸ˆì§€
          const coverage = this._laneCoverageIntervals(obstacles, pr);
          // ìƒˆ ì¥ì• ë¬¼ì˜ ì»¤ë²„ êµ¬ê°„(ìŠ¤í° ì§€ì : -size.h - 4)
          const y0 = -size.h - 4;
          const newInterval = { s: (pr.y - (y0 + size.h)) / speed, e: (pr.y + pr.h - y0) / speed };
          const overlaps = (a, b) => a && b && a.s <= b.e && b.s <= a.e;
          
          // ì™„ì „ ê· ë“± ë¬´ì‘ìœ„: ë ˆì¸ì„ ëœë¤ ìƒ˜í”Œë§í•˜ë©° ì•ˆì „ ì¡°ê±´ë§Œ í™•ì¸
          const maxTries = CFG.LANE_COUNT * 3;
          for (let tries = 0; tries < maxTries; tries++) {
            const lane = Math.floor(this.rng() * CFG.LANE_COUNT);
            // ì´ ì‹œê°„ëŒ€ì— ë§‰íˆëŠ” ë ˆì¸ ìˆ˜ ê³„ì‚° (í›„ë³´ ë ˆì¸ í¬í•¨)
            let blocked = 0;
            for (let k = 0; k < CFG.LANE_COUNT; k++) {
              if (k === lane) { blocked++; continue; }
              if (overlaps(newInterval, coverage[k])) blocked++;
            }
            if (blocked < CFG.LANE_COUNT) {
              // ì‚¬ìš© ê°€ëŠ¥ í’€ì—ì„œ í•˜ë‚˜ ì·¨ë“
              for (let i = 0; i < obstacles.length; i++) {
                const o = obstacles[i]; if (!o.active) {
                  const x = laneCenters[lane] - size.w/2; const y = y0;
                  // ì°¨ì„  ë‚´ë¶€ì—ì„œë§Œ ì¢Œìš° ì›€ì§ì´ë„ë¡ ê²½ê³„ ì„¤ì •
                  const laneLeft = laneCenters[lane] - laneW/2;
                  const minX = laneLeft + 4;
                  const maxX = laneLeft + laneW - size.w - 4;
                  o.spawn(lane, x, y, size.w, size.h, speed, minX, maxX, this.rng);
                  this.cool = this.nextInterval();
                  return o;
                }
              }
              // í’€ ë¶€ì¡±
              this.cool = this.nextInterval();
              return null;
            }
          }
          // ì—°ì† ì‹¤íŒ¨ ì‹œ ì•½ê°„ ì§€ì—° í›„ ì¬ë„ì „
          this.cool = Math.min(0.12, this.nextInterval());
          return null;
        }
      }

      class GameLoop {
        constructor(updateDraw) { this._raf = 0; this._last = 0; this._running = false; this.updateDraw = updateDraw; }
        start() { if (this._running) return; this._running = true; this._last = performance.now(); const tick = (t)=>{ if (!this._running) return; const dt = Math.min(0.05, (t - this._last)/1000); this._last = t; this.updateDraw(dt); this._raf = requestAnimationFrame(tick); }; this._raf = requestAnimationFrame(tick); }
        stop() { if (!this._running) return; this._running = false; cancelAnimationFrame(this._raf); }
        isRunning() { return this._running; }
      }

      // ===== UI/ìƒíƒœ =====
      const $ = (q) => document.querySelector(q);
      const canvas = $('#game');
      const ctx = canvas.getContext('2d');
      const scoreLine = $('#scoreLine');
      const bestLine = $('#bestLine');
      const livesLine = $('#livesLine');
      const pauseIcon = $('#pauseIcon');
      const muteIcon = $('#muteIcon');
      const startOverlay = $('#startOverlay');
      const pauseOverlay = $('#pauseOverlay');
      const gameOverOverlay = $('#gameOverOverlay');
      const startBtn = $('#startBtn');
      const resumeBtn = $('#resumeBtn');
      const restartBtn1 = $('#restartBtn1');
      const restartBtn2 = $('#restartBtn2');
      const goStartBtn = $('#goStartBtn');
      const muteBtn = $('#muteBtn');

      const audio = new AudioMgr();
      const rng = seededFromQuery();
      const spawner = new Spawner(rng);
      const player = new Player();
      const obstacles = Array.from({ length: CFG.POOL_SIZE }, () => new Obstacle());
      const loop = new GameLoop(step);
      const input = new Input(canvas);

      // ë™ì  ê°’(ë””ìì¸ ì¢Œí‘œê³„ ê¸°ì¤€)
      let S = 1; // draw scale (CSS px -> design unit)
      let DPR = Math.max(1, window.devicePixelRatio || 1);
      let W = CFG.DESIGN_W, H = CFG.DESIGN_H; // ë””ìì¸ í¬ê¸°
      let roadX = 0, roadW = 0, laneW = 0, laneCenters = [];
      let speed = CFG.BASE_SPEED; // px/s
      let elapsed = 0; // ì´ ê²½ê³¼
      let score = 0;
      let best = parseInt(localStorage.getItem(CFG.STORAGE_KEY) || '0', 10) || 0;
      let state = 'idle'; // idle|running|paused|gameover
      let debug = false;
      let stripeOffset = 0;
      let lives = 3;
      let hitCooldown = 0; // ë¬´ì  íƒ€ì´ë¨¸

      // ===== ë°˜ì‘í˜• ë¦¬ì‚¬ì´ì¦ˆ & ê¸€ë¡œë°œ ê·¸ë¦¬ê¸° ì¤€ë¹„ =====
      function resize() {
        // ê°€ì‹œ ì˜ì—­ì— ë§ì¶° 16:9 ìº”ë²„ìŠ¤ í¬ê¸° ì‚°ì¶œ (contain)
        const vw = window.innerWidth, vh = window.innerHeight;
        const targetW = Math.min(vw, Math.floor(vh * 16/9));
        const targetH = Math.floor(targetW * 9/16);
        // CSS í¬ê¸°
        canvas.style.width = targetW + 'px';
        canvas.style.height = targetH + 'px';
        // ì‹¤ì œ í”½ì…€ í¬ê¸°
        DPR = Math.max(1, window.devicePixelRatio || 1);
        canvas.width = Math.floor(targetW * DPR);
        canvas.height = Math.floor(targetH * DPR);
        // ë””ìì¸ ì¢Œí‘œê³„ë¡œ ìŠ¤ì¼€ì¼ (960x540 ê¸°ì¤€)
        W = CFG.DESIGN_W; H = CFG.DESIGN_H;
        S = targetW / W;
        // ë„ë¡œ/ë ˆì¸ ë°°ì¹˜ ê³„ì‚°
        roadW = W * (1 - CFG.ROAD_PADDING_X * 2);
        roadX = (W - roadW) / 2;
        laneW = roadW / CFG.LANE_COUNT;
        laneCenters = new Array(CFG.LANE_COUNT).fill(0).map((_, i) => roadX + i * laneW + laneW/2);
        // ë¼ë²¨/ì•„ì´ì½˜ ìœ„ì¹˜(ë¶€ëª¨: stage-wrap)
        const wrap = canvas.parentElement;
        wrap.style.width = targetW + 'px';
        wrap.style.height = targetH + 'px';
        // í”Œë ˆì´ì–´ ë°°ì¹˜ ê°±ì‹ 
        const pw = laneW * CFG.PLAYER_W_RATE; const ph = pw * CFG.PLAYER_H_RATE;
        player.setSize(pw, ph);
        // ë ˆì¸ì€ ìœ ì§€í•˜ë˜ í˜„ì¬/íƒ€ê²Ÿ ëª¨ë‘ ì„¼í„°ì— ë§ì¶¤ (ë¦¬ì‚¬ì´ì¦ˆ ì‹œ íŠ€ëŠ” ê²ƒ ë°©ì§€)
        player.setLane(player.lane, laneCenters);
        player.setBottomY(H);
      }
      window.addEventListener('resize', resize);

      // ===== ê²Œì„ ìƒíƒœ ì œì–´ =====
      function showOverlay(ov, show) { ov.classList.toggle('show', !!show); }
      function updateHUD() {
        scoreLine.textContent = `ì ìˆ˜: ${Math.floor(score)}`;
        bestLine.textContent = `ìµœê³ ì ìˆ˜: ${best}`;
        const hearts = 'â¤ï¸'.repeat(Math.max(0, lives));
        livesLine.textContent = hearts;
        pauseIcon.style.display = state === 'paused' ? 'block' : 'none';
        muteIcon.textContent = audio.muted ? 'ğŸ”‡' : 'ğŸ”Š';
      }
      function startGame() {
        // ì´ˆê¸°í™”
        score = 0; elapsed = 0; speed = CFG.BASE_SPEED; stripeOffset = 0;
        lives = 3; hitCooldown = 0;
        obstacles.forEach(o => o.kill());
        player.setLane(Math.floor(CFG.LANE_COUNT/2), laneCenters);
        state = 'running';
        showOverlay(startOverlay, false); showOverlay(pauseOverlay, false); showOverlay(gameOverOverlay, false);
        updateHUD();
        loop.start();
      }
      function gameOver() {
        state = 'gameover';
        loop.stop();
        audio.playCrash();
        const s = Math.floor(score);
        if (s > best) { best = s; localStorage.setItem(CFG.STORAGE_KEY, String(best)); }
        $('#finalScore').textContent = `ì ìˆ˜: ${s}`;
        $('#bestScore').textContent = `ìµœê³ ì ìˆ˜: ${best}`;
        showOverlay(gameOverOverlay, true);
        updateHUD();
      }
      function pauseToggle() {
        if (state === 'idle') { startGame(); return; }
        if (state === 'gameover') return;
        if (state === 'running') {
          state = 'paused'; loop.stop(); showOverlay(pauseOverlay, true);
        } else if (state === 'paused') {
          state = 'running'; showOverlay(pauseOverlay, false); loop.start();
        }
        updateHUD();
      }
      function restart() { if (state === 'idle') return startGame(); startGame(); }

      document.addEventListener('visibilitychange', () => {
        if (document.visibilityState !== 'visible' && state === 'running') {
          state = 'paused'; loop.stop(); showOverlay(pauseOverlay, true); updateHUD();
        }
      });

      // ===== ì…ë ¥ í•¸ë“¤ =====
      // í„°ì¹˜ì˜ ì¢Œ/ìš° íƒ­ì€ ë ˆì¸ ë³€ê²½, í‚¤ë³´ë“œëŠ” ì—°ì† ì´ë™(ìœ„ì˜ keydownì—ì„œ onAction í˜¸ì¶œ ì•ˆ í•¨)
      input.onAction = (dir) => { if (state !== 'running') return; player.move(dir, laneCenters); };
      input.onActionY = (dir) => { if (state !== 'running') return; player.moveY(dir, H); };
      input.onPause = () => pauseToggle();
      input.onRestart = () => restart();
      input.onToggleDebug = () => { debug = !debug; };
      input.onToggleMute = () => { audio.setMuted(!audio.muted); updateHUD(); };
      startBtn.addEventListener('click', () => { audio.ensureCtx(); startGame(); });
      resumeBtn.addEventListener('click', () => pauseToggle());
      restartBtn1.addEventListener('click', () => restart());
      restartBtn2.addEventListener('click', () => restart());
      goStartBtn.addEventListener('click', () => { state = 'idle'; lives = 3; hitCooldown = 0; showOverlay(gameOverOverlay, false); showOverlay(startOverlay, true); updateHUD(); });
      muteBtn.addEventListener('click', () => { audio.setMuted(!audio.muted); updateHUD(); });

      // ===== ë©”ì¸ ìŠ¤í… (ì—…ë°ì´íŠ¸+ë“œë¡œìš°) =====
      function step(dt) {
        if (state !== 'running') return drawFrame();
        elapsed += dt; score += CFG.SCORE_PER_SEC * dt; // ì‹œê°„ ì ìˆ˜
        if (hitCooldown > 0) hitCooldown = Math.max(0, hitCooldown - dt);
        // ë‚œì´ë„ ì¦ê°€(ì†ë„/ìŠ¤í°)
        const t = Math.min(1, elapsed / CFG.RAMP_TIME);
        speed = CFG.BASE_SPEED + (CFG.MAX_SPEED - CFG.BASE_SPEED) * t;
        spawner.update(dt, elapsed);
        // ì—°ì† ì…ë ¥(ì¢Œ/ìš°): í‚¤ë³´ë“œ ëˆ„ë¦„ ë™ì•ˆ ë¶€ë“œëŸ½ê²Œ ì¢Œìš° ì´ë™
        const vxDir = (input.left ? -1 : 0) + (input.right ? 1 : 0);
        if (vxDir !== 0) player.addX(vxDir * CFG.HORIZ_SPEED * dt, roadX, roadW);

        // ì—°ì† ì…ë ¥(ìƒ/í•˜)ìœ¼ë¡œ íƒ€ê²Ÿ Yë¥¼ ê°±ì‹ 
        const vyDir = (input.up ? -1 : 0) + (input.down ? 1 : 0);
        if (vyDir !== 0) player.addTargetY(vyDir * CFG.VERT_SPEED * dt, H);
        // í”Œë ˆì´ì–´ ë¶€ë“œëŸ¬ìš´ ì´ë™ ì—…ë°ì´íŠ¸
        player.update(dt, laneCenters, H);
        // í”Œë ˆì´ì–´ ë°•ìŠ¤(ìŠ¤í° ì•ˆì „ì„± ê²€ì‚¬/ì¶©ëŒì— í•„ìš”)
        const pr = player.rect();
        // ìŠ¤í°
        if (spawner.shouldSpawn()) {
          const sz = { w: laneW * CFG.PLAYER_W_RATE * (0.95 + rng()*0.1), h: 0 };
          sz.h = sz.w * CFG.PLAYER_H_RATE * (0.95 + rng()*0.1);
          spawner.spawn(obstacles, laneCenters, sz, speed * (0.95 + rng()*0.1), pr);
        }
        // ì—…ë°ì´íŠ¸/ì¶©ëŒ/ê·¼ì ‘ íŒì •
        for (let i = 0; i < obstacles.length; i++) {
          const o = obstacles[i]; if (!o.active) continue;
          const prevY = o.y; o.update(dt);
          const or = o.rect();
          // ì¶©ëŒ
          if (aabb(pr.x, pr.y, pr.w, pr.h, or.x, or.y, or.w, or.h)) {
            if (hitCooldown === 0) {
              // ë‚¨ì€ ëª©ìˆ¨ì´ 1ì´ë©´ ì¦‰ì‹œ ê²Œì„ì˜¤ë²„(ì‚¬ìš´ë“œëŠ” gameOverì—ì„œ ì²˜ë¦¬)
              if (lives <= 1) { return gameOver(); }
              // ì•„ë‹ˆë©´ ëª©ìˆ¨ ê°ì†Œ + í”¼ê²© ë¬´ì 
              lives -= 1; audio.playCrash(); hitCooldown = CFG.HIT_INVULN;
              // ì¶©ëŒí•œ ì¥ì• ë¬¼ì€ ì œê±°í•˜ì—¬ ì¦‰ì‹œ ì¬ì¶©ëŒ ë°©ì§€
              o.kill();
            }
          }
          // ê·¼ì ‘: ì¥ì• ë¬¼ì˜ í•˜ë‹¨ì´ í”Œë ˆì´ì–´ì˜ ìƒë‹¨ì„ ì§€ë‚˜ê°ˆ ë•Œ, ì„ê³„ê°’ ì´ë‚´
          const prevBottom = prevY + or.h; const nowBottom = o.y + or.h;
          if (!o.nearGiven && prevBottom <= pr.y && nowBottom >= pr.y) {
            const gap = Math.abs(pr.y - prevBottom);
            if (gap <= CFG.NEAR_MISS_THRESHOLD && !aabb(pr.x, pr.y, pr.w, pr.h, or.x, or.y, or.w, or.h)) {
              score += CFG.NEAR_MISS_BONUS; o.nearGiven = true; audio.playNear();
            } else { o.nearGiven = true; }
          }
          // í™”ë©´ í•˜ë‹¨ ì´íƒˆ ì‹œ ì œê±°
          if (o.offscreen(H)) o.kill();
        }
        // ì°¨ì„  ìŠ¤íŠ¸ë¼ì´í”„ ìŠ¤í¬ë¡¤
        stripeOffset = (stripeOffset + speed * dt) % 2000;
        drawFrame();
        updateHUD();
      }

      function drawFrame() {
        // ì¢Œí‘œê³„/ìŠ¤ì¼€ì¼ ì ìš©
        ctx.setTransform(DPR, 0, 0, DPR, 0, 0);
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        ctx.save(); ctx.scale(S, S);
        // ë°°ê²½/ë„ë¡œ
        ctx.fillStyle = getComputedStyle(document.documentElement).getPropertyValue('--panel');
        ctx.fillRect(0, 0, W, H);
        ctx.fillStyle = getComputedStyle(document.documentElement).getPropertyValue('--road');
        ctx.fillRect(roadX, 0, roadW, H);
        // ë ˆì¸ ë¶„ë¦¬ì„  (ë„íŠ¸)
        const laneColor = getComputedStyle(document.documentElement).getPropertyValue('--lane');
        ctx.strokeStyle = laneColor; ctx.lineWidth = 4;
        ctx.setLineDash([16, 20]);
        for (let i = 1; i < CFG.LANE_COUNT; i++) {
          const x = roadX + i * laneW; ctx.beginPath();
          // ìŠ¤í¬ë¡¤ ì—°ì¶œ: ì„  ì „ì²´ë¥¼ ì˜¤í”„ì…‹ë§Œí¼ ì´ë™ì‹œí‚´
          ctx.moveTo(x, - (stripeOffset % 36)); ctx.lineTo(x, H + 36);
          ctx.stroke();
        }
        ctx.setLineDash([]);

        // í”Œë ˆì´ì–´/ì¥ì• ë¬¼
        for (let i = 0; i < obstacles.length; i++) { if (obstacles[i].active) obstacles[i].draw(ctx); }
        player.draw(ctx);

        // ë””ë²„ê·¸: íˆíŠ¸ë°•ìŠ¤/ì„ê³„ì„ 
        if (debug) {
          ctx.strokeStyle = getComputedStyle(document.documentElement).getPropertyValue('--debug');
          ctx.lineWidth = 2; ctx.setLineDash([8, 8]);
          // player box
          ctx.strokeRect(player.x, player.y, player.w, player.h);
          // near-miss threshold line
          ctx.beginPath(); ctx.moveTo(roadX, player.y); ctx.lineTo(roadX + roadW, player.y); ctx.stroke();
          ctx.setLineDash([]);
          // obstacle boxes
          for (let i = 0; i < obstacles.length; i++) {
            const o = obstacles[i]; if (!o.active) continue; ctx.strokeRect(o.x, o.y, o.w, o.h);
          }
        }
        ctx.restore();
      }

      // ===== ì´ˆê¸° ì„¸íŒ… =====
      function boot() { resize(); showOverlay(startOverlay, true); updateHUD(); drawFrame(); }
      boot();

      // ===== ê°„ë‹¨ ìŠ¤ëª¨í¬ í…ŒìŠ¤íŠ¸ =====
      function runSmokeTests() {
        const tests = [];
        function assert(name, cond) { tests.push({ name, ok: !!cond }); }
        // ì¶©ëŒ í…ŒìŠ¤íŠ¸
        assert('AABB overlap', aabb(0,0,10,10, 5,5,5,5) === true);
        assert('AABB separate', aabb(0,0,10,10, 20,20,5,5) === false);
        // ë ˆì¸ í´ë¨í”„
        assert('Clamp lane low', clamp(-1, 0, 2) === 0);
        assert('Clamp lane hi', clamp(9, 0, 2) === 2);
        const okAll = tests.every(t => t.ok);
        console.log('[SmokeTests]', okAll ? 'PASS' : 'FAIL');
        for (const t of tests) console.log('-', t.ok ? 'âœ…' : 'âŒ', t.name);
        return okAll;
      }
      window.runSmokeTests = runSmokeTests;

      // ===== ê°œì„  í›… (ì£¼ì„) =====
      // TODO: v2ì—ì„œ ìë™ì°¨ ìŠ¤í”„ë¼ì´íŠ¸ë¥¼ ë²¡í„° ê²½ë¡œë¡œ ê°œì„ , íŒŒí‹°í´ íš¨ê³¼ ì¶”ê°€
      // TODO: ì¥ì• ë¬¼ íŒ¨í„´(ì°¨í­/ì†ë„/ë ˆì¸) ë‹¤ì–‘í™”, ë‘ ë¬¼ì²´ ë™ì‹œ ìŠ¤í°
      // TODO: ì ìˆ˜ ë©€í‹°í”Œë¼ì´ì–´(ì—°ì† ê·¼ì ‘ ë³´ë„ˆìŠ¤)
      // TODO: ëª¨ë°”ì¼ í–…í‹± í”¼ë“œë°± (Vibration API)
      // TODO: ì ‘ê·¼ì„± â€” ìº”ë²„ìŠ¤ ì™¸ HUDë¥¼ DOM í…ìŠ¤íŠ¸ë¡œ ì¤‘ë³µ ì œê³µ
    </script>

    <!--
    README (ìš”ì•½)
    - ë¡œì»¬ì—ì„œ ì—¬ëŠ” ë°©ë²•:
      1) ì´ íŒŒì¼(car/index.html)ì„ ë¸Œë¼ìš°ì €ì—ì„œ ì§ì ‘ ë”ë¸”í´ë¦­í•´ ì—½ë‹ˆë‹¤.
      2) ëª¨ë°”ì¼ì—ì„œëŠ” íŒŒì¼ ê³µìœ /ì—´ê¸°ë¥¼ í†µí•´ ì‹¤í–‰í•˜ì„¸ìš”.

    - ë‹¤ìŒ ê°œì„  ì•„ì´ë””ì–´:
      - ë‚œì´ë„ ê³¡ì„  ì„¸ë¶„í™” ë° ì›¨ì´ë¸Œ ì‹œìŠ¤í…œ
      - í”Œë ˆì´ì–´ ì´ë™ ì• ë‹ˆë©”ì´ì…˜(ë¶€ë“œëŸ¬ìš´ ì°¨ì„  ë³€ê²½), í™”ë©´ ì‰ì´í¬
      - ìƒ‰ë§¹ ì¹œí™” íŒ”ë ˆíŠ¸/ì»¨íŠ¸ë¼ìŠ¤íŠ¸ ì˜µì…˜, í‚¤ ë¦¬ë§µ UI
      - ë¦¬í”Œë ˆì´(ì‹œë“œ ê³ ì •) ê³µìœ  ë§í¬ ìƒì„±
    -->
  </body>
  </html>
