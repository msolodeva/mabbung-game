# 3D 체스 게임

Three.js를 사용한 인터랙티브 3D 체스 게임입니다. 지능적인 AI 봇과 대결할 수 있습니다.

## 기능

### 게임 기능
- ✨ 아름다운 3D 그래픽과 부드러운 애니메이션
- ♟️ 완전한 체스 규칙 구현
- 🤖 Minimax 알고리즘 기반의 지능적인 AI 봇
- 🎨 정교한 3D 체스 말 모델 (여러 파트 조합)
- 📝 이동 기록 추적
- 👻 먹힌 기물 표시 (유니코드 체스 기호)
- ↩️ 무르기 기능
- 🎮 직관적인 마우스 컨트롤

### 체스 규칙
- 모든 체스 말의 이동 규칙 완벽 구현 (폰, 룩, 나이트, 비숍, 퀸, 킹)
- 체크 및 체크메이트 감지
- 유효한 이동만 허용 (체크 상태를 피하는 이동)
- 폰의 특수 규칙 (첫 이동 시 2칸, 대각선 공격)
- **캐슬링 (Castling)** - 킹사이드/퀸사이드 모두 지원
- **앙파상 (En Passant)** - 폰의 특수 공격

### AI 특징
- **향상된 Minimax 알고리즘**: 4단계 깊이 탐색
- **Alpha-Beta 가지치기**: 성능 최적화
- **플레이어 응수 시뮬레이션**: 백의 가능한 응수를 미리 계산하여 최적의 수 선택
- **고급 보드 평가 함수**: 
  - 기물별 정교한 위치 가치 테이블 (Piece-Square Tables)
  - 이동성(Mobility) 평가 - 가능한 수가 많을수록 유리
  - 킹 안전성(King Safety) 평가 - 주변 아군 말로 보호
  - 위협도(Threat) 평가 - 공격하는 상대 기물의 가치
  - 체크/체크메이트 감지 및 우선순위
  - Move Ordering - 유망한 이동을 먼저 평가
- 전략적이고 도전적인 플레이 (상급 수준)

## 실행 방법

1. `index.html` 파일을 웹 브라우저로 엽니다
2. 또는 로컬 서버를 실행합니다:
   ```bash
   # Python 3
   python -m http.server 8000
   
   # 또는 Node.js의 http-server
   npx http-server
   ```
3. 브라우저에서 `http://localhost:8000` 접속

## 사용법

### 기본 조작
- **말 선택**: 흰색 말을 클릭하여 선택
- **이동**: 녹색으로 표시된 유효한 위치를 클릭하여 이동
- **카메라**: 마우스 드래그로 시점 회전, 스크롤로 줌 인/아웃

### 버튼
- **새 게임**: 게임을 처음부터 다시 시작
- **무르기**: 이전 이동 취소 (플레이어와 AI 턴 모두 취소)

### 게임 진행
1. 플레이어(흰색)가 먼저 시작합니다
2. 말을 선택하면 가능한 이동 위치가 녹색으로 표시됩니다
3. 유효한 위치를 클릭하여 이동합니다
4. AI(검은색)가 자동으로 응수합니다
5. 체크메이트가 발생하면 게임이 종료됩니다

## 기술 스택

- **Three.js**: 3D 그래픽 렌더링
- **JavaScript (ES6+)**: 게임 로직 구현
- **HTML5/CSS3**: UI 및 스타일링

## 3D 체스 말 디자인

각 체스 말은 여러 3D 파트를 조합하여 실제 체스 말처럼 정교하게 디자인되었습니다:

- **폰**: 베이스, 몸체, 목, 구형 머리로 구성 (4개 파트)
- **룩**: 성 모양의 베이스, 몸체, 상단에 4개의 성벽 돌출부 (7개 파트)
- **나이트**: 정교한 말 모양 - 가슴, 목, 머리, 주둥이, 턱, 눈(2), 귀(2), 갈기(3), 콧구멍(2) 포함 (15개 파트)
- **비숍**: 주교 모자 형태, 상단에 십자가 장식 (5개 파트)
- **퀸**: 화려한 왕관, 8개의 구슬 장식과 정상의 큰 구슬 (12개 파트)
- **킹**: 웅장한 왕관, 상단에 십자가 (5개 파트)

## 게임 구조

### 주요 클래스: ChessGame

#### 초기화 메서드
- `setupScene()`: 3D 장면, 카메라, 조명 설정
- `setupBoard()`: 체스 보드 생성
- `setupPieces()`: 체스 말 초기 배치
- `setupControls()`: 카메라 컨트롤 설정
- `setupRaycaster()`: 마우스 인터랙션 처리

#### 게임 로직 메서드
- `getValidMoves(piece)`: 특정 말의 유효한 이동 계산
- `getPawnMoves()`, `getRookMoves()`, etc.: 각 말의 이동 규칙
- `isInCheck(color)`: 체크 상태 확인
- `isCheckmate(color)`: 체크메이트 확인
- `wouldBeInCheck(piece, move)`: 이동 후 체크 상태 예측

#### AI 메서드
- `aiMove()`: AI의 턴 처리
- `getBestMove()`: 최적의 이동 찾기
- `minimax()`: Minimax 알고리즘 구현
- `evaluateBoard()`: 보드 상태 평가

#### UI 메서드
- `selectPiece()`: 말 선택 처리
- `highlightValidMoves()`: 유효한 이동 위치 표시
- `makeMove()`: 이동 실행
- `animatePieceMove()`: 부드러운 이동 애니메이션

## AI 알고리즘 상세

### Minimax 알고리즘
AI는 게임 트리를 탐색하여 최선의 수를 찾습니다:

1. **탐색 깊이**: 4단계 (향상된 전략성)
2. **Alpha-Beta 가지치기**: 불필요한 분기 제거로 성능 향상
3. **Move Ordering**: 공격적인 이동을 먼저 탐색하여 가지치기 효율 증가
4. **향상된 평가 함수**:
   ```
   점수 = Σ(말 가치 + 위치 가치 + 이동성) + 킹 안전성
   
   말 가치:
   - 폰: 100
   - 나이트: 320
   - 비숍: 330
   - 룩: 500
   - 퀸: 900
   - 킹: 20000
   
   위치 가치: 기물별 최적 위치 테이블 (Piece-Square Tables)
   - 각 기물마다 보드의 각 위치에 대한 가치를 미리 정의
   - 예: 나이트는 중앙에, 폰은 전진할수록 가치 상승
   
   이동성: 가능한 이동 수 × 2
   킹 안전성: 주변 아군 말 개수 × 5
   
   체크메이트: ±100000
   체크 상태: ±50
   ```

### 최적화 및 전략
- **Alpha-Beta 가지치기**: 탐색 속도 향상
- **플레이어 응수 시뮬레이션**: 백의 최선 응수를 예측하여 더 안전한 수 선택
- **Move Ordering**: 유망한 수를 먼저 탐색하여 가지치기 효율 극대화
  - 기물 잡기 우선
  - 중앙 통제 고려
  - 체크 주는 수 우선
- **Piece-Square Tables**: 위치 기반 전략
- **이동성 평가**: 활동적인 플레이
- **위협도 평가**: 공격 대상의 가치 고려
- **킹 안전성**: 방어적 플레이
- **깊이 4 탐색**: 상급 수준의 실력

## 체스 특수 규칙

### 캐슬링 (Castling)
킹과 룩을 동시에 이동하는 특수 규칙입니다.

**조건:**
- 킹과 룩이 한 번도 움직이지 않았을 것
- 킹과 룩 사이에 다른 기물이 없을 것
- 킹이 체크 상태가 아닐 것
- 킹이 지나가는 경로가 공격받지 않을 것

**종류:**
- **킹사이드 캐슬링 (짧은 캐슬링)**: 킹이 2칸 오른쪽으로, 룩이 킹을 넘어 왼쪽으로
- **퀸사이드 캐슬링 (긴 캐슬링)**: 킹이 2칸 왼쪽으로, 룩이 킹을 넘어 오른쪽으로

### 앙파상 (En Passant)
상대 폰이 시작 위치에서 2칸 전진했을 때 가능한 특수 공격입니다.

**조건:**
- 상대 폰이 시작 위치에서 2칸 전진했을 것
- 내 폰이 상대 폰 옆에 위치할 것
- 상대 폰이 2칸 전진한 직후 턴에만 가능

**효과:**
- 폰을 대각선으로 이동시켜 상대 폰을 잡음

## 향후 개선 사항

- [x] 앙파상, 캐슬링 등 고급 체스 규칙 추가
- [ ] 폰 프로모션 (Pawn Promotion)
- [ ] 난이도 선택 (탐색 깊이 조절)
- [ ] 멀티플레이어 모드
- [ ] 게임 저장/불러오기
- [ ] 더 정교한 3D 모델
- [ ] 사운드 효과
- [ ] 게임 분석 기능
- [ ] Opening book 추가

## 라이선스

MIT License

## 개발자

mabbung-game 프로젝트의 일부로 개발되었습니다.

